[Console]::Title = "AutoFlow Hub"

# Import-Module Az
#######################################################
# Import Az network module while supress the output
Import-Module -Name Az.Network -Verbose *>&1 | Out-Null
Import-Module Az.ConnectedMachine -Verbose *>&1 | Out-Null
########################################################

<#
.SYNOPSIS
Auto Flow Hub Script Index

.DESCRIPTION
Welcome to Auto Flow Hub, developed by Ahmed Ali. This script serves as an index for various automation tasks.

.NOTES
File Name      : ScriptIndex.ps1
Prerequisite   : Ensure you have the required modules installed.
#>


    # Loading message with increasing dots
    $loadingMessage = "Loading deployment, please wait"
    for ($i = 1; $i -le 5; $i++) {
        $dots = "." * $i
        Write-Host -NoNewline "$loadingMessage$dots" -ForegroundColor Blue
        Start-Sleep -Milliseconds 500  # Adjust the delay time as needed
        Clear-Host  # Clear the line to create the animation effect
        # Write-Host "`e[2J`e[H"
    }
    


# $job = Start-Job -ScriptBlock { script is here }

#         # Wait for the job to complete
#         Wait-Job -Job $job


#         # Retrieve the output
#         $output = Receive-Job -Job $job
        
    
#endregion Introduction


#region Password CONFIRMATION

#region Password CONFIRMATION  V.1
#############################
# Password CONFIRMATION  V.1
##############

# # Prompt for a password
# $password = Read-Host -Prompt "Enter the password" -AsSecureString

# # Convert the secure password to plain text for comparison
# $plainTextPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

# # Check if the entered password is correct
# if ($plainTextPassword -eq "YoucanCall") {
#     Write-Host -ForegroundColor green "Password accepted. Proceeding..."
#     sleep 1
#     # Your main script logic goes here
# } else {
#     Write-Host "Incorrect password. Exiting deployment."
#     sleep 1
#     exit
# }
#endregion Password CONFIRMATION  V.1


#region Password CONFIRMATION  V.2
#############################
# Password CONFIRMATION  V.2
##############
# $maxAttempts = 3
# $attempts = 0
# $correctPassword = "1"

# do {
  
#     # Prompt for a password
#     Write-Host -ForegroundColor Blue "Enter the password: " -NoNewLine
#     $password = Read-Host  -AsSecureString

#     # Convert the secure password to plain text for comparison
#     $plainTextPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

#     # Check if the entered password is correct
#     if ($plainTextPassword -eq $correctPassword) {
#         clear-host
#         Write-Host -ForegroundColor Blue "Password accepted. Proceeding..."
#         sleep 1
#           # Clear the screen
#     Clear-Host
#         # Your main script logic goes here
#         break
#     } else {
#         Write-Host -ForegroundColor Red "Incorrect password. Attempts remaining: $($maxAttempts - $attempts - 1)"
#         $attempts++
#     }
# } while ($attempts -lt $maxAttempts)

# if ($attempts -eq $maxAttempts) {
#     Write-Host -ForegroundColor Red "Maximum attempts reached. Exiting deployment."
#     sleep 5
#     exit
# }
#endregion Password CONFIRMATION  V.2

#region Password CONFIRMATION  V.3
<#
This approach involves modifying the script to add an "exit" command at the beginning of the script after three failed attempts. Here is your modified script with this functionality added
Add-ExitCommand Function:

This function writes the "exit" command at the beginning of the script. It reads the current content of the script, prepends the "exit" command, and writes the modified content back to the script file.
Check for Existing "exit" Command:

Before entering the password prompt loop, the script checks if the first line of the script contains the "exit" command. If it does, the script displays a message and exits immediately.
Password Prompt Loop:

The loop prompts the user for the password, converts the secure string to plain text for comparison, and checks if the entered password is correct.
If the password is incorrect, the attempt count is incremented and a message is displayed showing the remaining attempts.
Maximum Attempts Reached:

If the user reaches the maximum number of attempts, the script writes the "exit" command to the script file and then exits.
Note:
This method relies on modifying the script file itself, which might not be suitable for all scenarios or environments.
Ensure that the script has the necessary permissions to modify itself.
This approach can be bypassed if the user has access to edit the script file directly.
#>


# Initialize the number of attempts
$maxAttempts = 3
$attempts = 0
$correctPassword = "1"
$scriptPath = $MyInvocation.MyCommand.Definition

# Function to write the "exit" command to the script
function Add-ExitCommand {
    $exitCommands = @(
        "Write-Host -ForegroundColor Red `"Maximum password attempts reached. Exiting deployment.`"",
        "Start-Sleep -Seconds 5",
        "exit`r`n"
    )
    $scriptContent = Get-Content -Raw -Path $scriptPath
    $newContent = $exitCommands + $scriptContent
    Set-Content -Path $scriptPath -Value $newContent
}

# Check if the script already has an "exit" command at the beginning
$firstLine = Get-Content -Path $scriptPath -TotalCount 1
if ($firstLine -match "exit") {
    Write-Host -ForegroundColor Red "The application will not work due to 3 previous wrong password attempts."
    Write-Host -ForegroundColor Red "Maximum attempts reached. Exiting deployment."
    Start-Sleep -Seconds 5
    exit
}

do {
    # Prompt for a password
    Write-Host -ForegroundColor Blue "Enter the password: " -NoNewLine
    $password = Read-Host -AsSecureString

    # Convert the secure password to plain text for comparison
    $plainTextPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

    # Check if the entered password is correct
    if ($plainTextPassword -eq $correctPassword) {
        Clear-Host
        Write-Host -ForegroundColor Blue "Password accepted. Proceeding..."
        Start-Sleep -Seconds 1
        # Clear the screen
        Clear-Host
        # Your main script logic goes here
        break
    } else {
        Write-Host -ForegroundColor Red "Incorrect password. Attempts remaining: $($maxAttempts - $attempts - 1)"
        $attempts++
    }
} while ($attempts -lt $maxAttempts)

if ($attempts -eq $maxAttempts) {
    Write-Host -ForegroundColor Red "Maximum attempts reached. Exiting deployment."
    Start-Sleep -Seconds 5
    Add-ExitCommand
    exit
}




#endregion Password CONFIRMATION  V.3

#endregion Password CONFIRMATION 


#region ASCII ART URL https://patorjk.com/  V 1.0
# $asciiArt  = @"
#                _        ______ _                 _    _       _     
#     /\        | |      |  ____| |               | |  | |     | |    
#    /  \  _   _| |_ ___ | |__  | | _____      __ | |__| |_   _| |__  
#   / /\ \| | | | __/ _ \|  __| | |/ _ \ \ /\ / / |  __  | | | | '_ \ 
#  / ____ \ |_| | || (_) | |    | | (_) \ V  V /  | |  | | |_| | |_) |
# /_/    \_\__,_|\__\___/|_|    |_|\___/ \_/\_/   |_|  |_|\__,_|_.__/                                                                
# "@

# # Display the ASCII art
# Write-Host $asciiArt -ForegroundColor Blue 
# sleep 2
# clear-host
#endregion

#region ASCII ART URL https://patorjk.com/  V 2.0
$asciiArt  = @"
*----------------------------------------------------------------------*
               _        ______ _                 _    _       _         
    /\        | |      |  ____| |               | |  | |     | |        
   /  \  _   _| |_ ___ | |__  | | _____      __ | |__| |_   _| |__      
  / /\ \| | | | __/ _ \|  __| | |/ _ \ \ /\ / / |  __  | | | | '_ \     
 / ____ \ |_| | || (_) | |    | | (_) \ V  V /  | |  | | |_| | |_) |    
/_/    \_\__,_|\__\___/|_|    |_|\___/ \_/\_/   |_|  |_|\__,_|_.__/                                                               
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
"@

# Display the ASCII art
Write-Host "$asciiArt  Developed by Ahmed Ali`n" -ForegroundColor Blue
sleep 2
clear-host
#endregion


#region Check the PowerShell version
$psVersion = $PSVersionTable.PSVersion

if ($psVersion.Major -eq 5) {
    # Code specific to PowerShell 5
    # Write-Host -ForegroundColor Green "Running in PowerShell $($psVersion )"
    Write-Host -ForegroundColor Blue " $($psVersion )"

    # Add your PowerShell 5 specific code here
}
elseif ($psVersion.Major -eq 7) {
    # Code specific to PowerShell 7
    # Write-Host -ForegroundColor Green "Running in PowerShell $($psVersion )"
    Write-Host -ForegroundColor Blue " $($psVersion )"

    # Add your PowerShell 7 specific code here
}
else {
    # Code for other versions
    Write-Host -ForegroundColor  Red "Unsupported PowerShell version"
    # Add code for handling other versions if needed
}
sleep 1
Clear-Host
#endregion Check the PowerShell version


#region LOGGING CONFIRMATION

#############################
# LOGGING CONFIRMATION
##############
# Get current context
# Disconnect-AzAccount  *>$null

$currentContext = Get-AzContext -WarningAction SilentlyContinue

# if ($null -eq $currentContext) {
#     Write-Host -ForegroundColor Yellow "Get-AzAccessToken: Authentication failed against resource https://graph.microsoft.com. User interaction is required. This may be due to the conditional access policy settings such as multi-factor authentication (MFA). Please rerun 'Connect-AzAccount' with additional parameter '-AuthScope https://graph.microsoft.com'.
#     Invoke-RestMethod: Cannot validate argument on parameter 'Uri'. The argument is null or empty. Provide an argument that is not null or empty, and then try the command again."
#     Write-Host -ForegroundColor Green "`ncontinuing in 5 seconds."
#     sleep 3
#     Clear-Host
#     }

# Get Azure AD Tenant Details
$tenantId = (Get-AzContext).Tenant.Id 

######################################################
######################################################
# Get Tenant NAME using Microsoft Graph API
# Call Microsoft Graph API to get Tenant details
$graphApiUrl = "https://graph.microsoft.com/v1.0/organization?$select=displayName"
$tenantDetails = Invoke-RestMethod -Uri $graphApiUrl -Headers @{"Authorization" = "Bearer $((Get-AzAccessToken -ResourceUrl "https://graph.microsoft.com").Token)"}

if ($null -eq $tenantDetails) {
Write-Host -ForegroundColor Yellow "Get-AzAccessToken: Authentication failed against resource https://graph.microsoft.com. User interaction is required. This may be due to the conditional access policy settings such as multi-factor authentication (MFA). Please rerun 'Connect-AzAccount' with additional parameter '-AuthScope https://graph.microsoft.com'.
Invoke-RestMethod: Cannot validate argument on parameter 'Uri'. The argument is null or empty. Provide an argument that is not null or empty, and then try the command again."
Write-Host -ForegroundColor Green "`ncontinuing in 5 seconds."
sleep 3
Clear-Host
}

# Display the Tenant Name
$tenantName = $tenantDetails.value.displayName
######################################################
######################################################








######################################################
######################################################
# Hashed the below as it is not always working
# Get Tenant NAME
# $tenant = Get-AzTenant -TenantId $tenantId -WarningAction SilentlyContinue
# $tenantname = $tenant.Name
######################################################
######################################################







######################################################
######################################################
# Hashesh the below to Get tenant name by Azure AD Powershell but its not working with powershell core so its need to switch windows powershell , and when switch windows powershell i faced issue {Method 'get_SerializationSettings' in type 'Microsoft.Azure.Management.Internal.Resources.ResourceManagementClient' from assembly 'Microsoft.Azure.PowerShell.Clients.ResourceManager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35' does not have an implementation.}

# Install and import the AzureAD module
# Install-Module -Name AzureAD -Force -AllowClobber
# Import-Module AzureAD

# Connect to Azure AD
# Connect-AzureAD

# Get the current context
# $context = Get-AzureADTenantDetail

# Display the Tenant Name
# $tenantname = $context.DisplayName
# Write-Host "Tenant Name: $tenantName"
####################################################
######################################################




 # Display brand information
#  Write-Host "AutoFlow Hub - Developed by Ahmed Ali`n" -ForegroundColor Blue
 Write-Host $asciiArt -ForegroundColor Blue 
 Write-Host ""
